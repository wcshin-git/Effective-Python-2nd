## Better way 11. 시퀀스를 슬라이싱하는 방법을 익혀라

파이썬에는 시퀀스를 여러 조각(슬라이스)으로 나누는 슬라이싱 구문이 있다.

슬라이싱할 때 리스트의 인덱스 범위를 넘어가는 시작과 끝 인덱스는 조용히 무시된다. 반면 같은 인덱스에 직접 접근하면 예외가 발생한다. 

```python
first_twenty_items = a[:20]
last_twenty_items = a[-20:]

a[20]
>>> 에러 남
```

리스트를 슬라이싱한 결과는 완전히 새로운 리스트이며, 슬라이싱한 결과로 얻은 리스트를 변경해도 원래 리스트는 바뀌지 않는다.

```python
a = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
b = a[3:]
print('이전:', b)
b[1] = 99
print('이후:', b)
print('변화 없음:', a)

>>>
이전: ['d', 'e', 'f', 'g', 'h']
이후: ['d', 99, 'f', 'g', 'h']
변화 없음: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']

a[3] = 'asdf'
print(b)

>>>
['d', 99, 'f', 'g', 'h']

# 슬라이싱은 얕은 복사를 함: 전체 객체(숲)는 메모리 주소가 다른데, 원소(나무)는 메모리 주소가 같음
a = [1, 2, [1,2,3], 4]
b = a[1:]

b[1].append(4)

>>>
print(a): [1, 2, [1,2,3,4], 4]
print(b): [1, 2, [1,2,3,4], 4]
```

대입에 슬라이스를 사용하면 원본 리스트에서 지정한 범위에 들어 있는 원소를 변경한다. 언패킹 대입(예를 들면, a, b = c[:2])과 달리 슬라이스 대입에서는 슬라이스와 대입되는 리스트의 길이가 같을 필요가 없다.

```python
# 리스트에 지정한 슬라이스 길이보다 대입되는 배열의 길이가 더 짧은 경우
print('이전:', a)
a[2:7] = [99, 22, 14]
print('이후:', a)

>>>
이전: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
이후: ['a', 'b', 99, 22, 14, 'h']

# 리스트에 지정한 슬라이스 길이보다 대입되는 배열의 길이가 더 긴 경우
print('이전:', a)
a[2:3] = [47, 11]
print('이후:', a)

>>>
이전: ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
이후: ['a', 'b', 47, 11, 'd', 'e', 'f', 'g', 'h']

```

슬라이싱에서 시작과 끝 인덱스를 모두 생략하면 원래 리스트를 복사한 새 리스트를 얻는다.

```python
b = a[:]
assert b == a and b is not a

# 참고
b = a
assert b == a and b is a
# 이 경우엔 메모리 주소를 똑같이 가리키고 있어서 한 쪽을 바꾸면 다른쪽도 바뀜
```

**기억해야할 내용**
- 슬라이싱할 때는 간결하게 하라. 시작 인덱스에 0을 넣거나, 끝 인덱스에 시퀀스 길이를 넣지 말라.
- 슬라이싱은 범위를 넘어가는 시작 인덱스나 끝 인덱스도 허용한다. 따라서 시퀀스의 시작이나 끝에서 길이를 제한하는 슬라이스를 싑게 표현할 수 있다.
- 리스트 슬라이스에 대입하면 원래 시퀀스에서 슬라이스가 가리키는 부분을 대입 연산자 오른쪽에 있는 시퀀스로 대치한다. 이때 슬라이스와 대치되는 시퀀스의 길이가 달라도 된다.
